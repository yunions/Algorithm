# 03. 검색알고리즘

2021.06.20

## (1) 검색 알고리즘

### 검색알고리즘, Search란?

데이터 집합에서 **원하는 값**을 가진 원소를 **찾아내는 것**

- key : 검색 조건 중 주목하는 항목

### 검색의 종류

1. linear Search
2. Binary Search : 일정한 규칙으로 늘어놓은 데이터 집합에서 아주 빠른 검색 수행
3. Hash

## (2) Linear Search

### Linear Search란?

순차 검색(Sequential Search)라고도 하며, 무작위로 늘어놓은 데이터 집합에서 검색 실행

가장 쉬운 검색 방식이지만 시간 복잡도가 크다(O(n) = n)

```python
def search(array, key) : 
    for i in range(array) :
        if array[i] == key
        	return i
        
array1 = ['a','b','c','d']
key = 'c'

print(search(array1, key))
```



### Linear Search의 문제점

- If key가 list의 마지막(n-1번째)에 있다면?

  -> Sequential Search는 총 n번의 탐색 실행, 즉 데이터의 숫자가 커질수록 time complexity가 커짐!

  

## (3) Binary Search

### Binary Search란?

Sequence형을 2개로 나눠 검색 실행(**단, 데이터는 정렬(sort)되야 함**)

```python
def BinarySearch(array, key, low, high) :
    if low > high : # 예외 처리
   		return false
    
    mid = (low + high) / 2 # 나머지 상관 없음
    
    if value < array[mid] : # 찾는 값이 가운데 기준 왼쪽에 있다
        return binarySearch(array, value, low, mid-1)
    elif array[mid] > value : # 찾는 값이 가운데 기준 오른쪽에 있다
        return binarySearch(array, value, mid+1, high)
    else :
        return mid
```

- Binary Search의 Time Complexity : O(n) = log(n)

### Binary Search vs Linear Search

|               | 정렬여부               | 최소          | 최악                     |
| :-----------: | ---------------------- | ------------- | ------------------------ |
| Binary Search | 정렬된 상태에서만 가능 | 최소 1번 비교 | 최대 n번 비교 수행       |
| Linear Search | 상관 없음              | 최소 1번 비고 | 최대 log n 번의 비교수행 |



## (4) Hash

### Hash란?

데이터 검색 및 추가, 삭제에 용이한 알고리즘

### Hash의 특징

- 해싱된 키(Hash key)를 가지고 배열의 인덱스로 사용하기 때문에 삽입/삭제/검색이 빠름
- 해시함수(Hash function)를 사용하는데 추가적인 연삭 필요
- 해시 테이블(Hash Table)의 크기가 유한하고, 해시 함수 특성상 해시 충돌(Hash Collision)이 발생 할 수 밖에 없음
- 충돌이 없거나 적으면 O(1)의 상수 시간에 가까워지고, 충돌이 발생하면 할수록 성능이 점점 O(n)에 가까워짐
- int 값들이 들어있는 key의 해시 함수는 `나누기`함수가 대표적

**But** hash function 후 같은 해시값이 나온다면?

- 해결방법

  1. Chanined hash 사용
  2. Open hash 활용

  

### Chanined hash

: hash fuction을 통해 나온 값이 같은 데이터를 chain 모양의 linked list로 연결하는 방법으로 open hashing이라고도 합니다

- 설명 추가하기

### Open Addressing

: hash collision이 발생 했을 떄, rehashing(재해시)를 통해 빈 버킷을 찾아 데이터를 추가하는 방법으로 closed hashing이라고도 합니다. → 재해시 반복하는 과정을 빗대어 linear probing 선형 탐사법이라고도 함

- 설명 추가하기

### Chanined hash vs Open addressing

- chaning과 다르게 open addressin의 경우 추가적인 저장공간 필요 없음
- Open addressing의 경우 삽입, 삭제시 오버헤드가 적음
  - **오버헤드(Overhead)** : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등을 말한다

- 저장할 데이터가 많은 경우, Chain / 저장할 데이터가 적은 경우, Open addressing이 유리하다

## (+) 빅오 표기법(Big-O notation)

### 빅오 표기법의 수학적 정의

$$
모든 \ n \geq n_0 > 0에 \ 대하여 \ 0\le f(n) \le k*g(n)인 \ 양의 \ 상수 \ k와 \ n_0가 \ 존재하면 \ f(n) = O(g(n))이다
$$

![img](03. 검색알고리즘.assets/99EF1E395C7EB4B601)